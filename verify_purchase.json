{"noir_version":"1.0.0-beta.5+c651df6e2bf5db3966aa0c95abea2fc4c69d4513","hash":"14108268547916523936","abi":{"parameters":[{"name":"header","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":576,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"header_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"body","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":1216,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"pubkey","type":{"kind":"struct","path":"zkemail::dkim::RSAPubkey","fields":[{"name":"modulus","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"redc","type":{"kind":"array","length":18,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"purchase_number","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"purchase_number_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"from_email_address","type":{"kind":"array","length":60,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"from_email_address_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"to_email_address","type":{"kind":"array","length":60,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"to_email_address_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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S4T1EmG9REpDn8J6iZSGPqn3mkJeIuQlQl4irJcI6yXoXvPUve6/Q6fu9cAGdnCAleGdutcDDXQwwPp9k7rTIqXutEh0r4nuNdG9JvVek3qvSb3XlIG3gTfWS4T1EqlaSCmsl1DvNan3muhek3qvSb3XpN5rUu81qfea6F4T3Wuie010r0m916Tea1LvNan3mtR7TXSvSb3XpN5rUu81qfea1HtNdK/5/2vq73alyYHoPPNedNwHxeBfxNyKIRi2RjMQIFiGxh7AMHTv7l3MLD4njVg7v654k2SuTbKCuW/da92617p1r3Xf91r3fa913/da932vdd/3Wrfute77Xuu+77Xu+17rvu+17vte69a91q17rVv3Wrfute77Xuu+77Xu+17rvu+17vte69a91n3fa933vdZ932vd973Wfd9r3brXunWvdete69a91n3fa933vdZ932vdute6da91617r1r3Wfd9r3brXunWvdete69a91q17rVv3WvNXX1LzrnHm73ucmneNc+te69a91vzVl9S8a5wZ997uGufWvdate61b91q37rVu3WvN3/tLat41zrzzknnXOLfutW7da83f+0tq3jXOvPOSeeclt+61bt1r3brXunWvdetea14vmXeNM6+XzOslt+61bt1rzesl865x5vWSeb3k1r3WrXutW/dat+61bt1rzeslc92WvF4yr5fcute6da81r5fMdVvyesm8XnLrXuvWvdate61b91q37rWeutfvAN/3Cdj3Cdj3CfjVvdbM+wT8/m5fzd/f7av5+5sW9dS9fp+LnDf87Zk/da8nzBv+djDm9ZJZtyWvl8zrJfN6ya17rXm9ZNZtyesl83rJul5y617r1r3WrXutW/da685L1u9sX607L1l3XrLuvOTWvda685L1O9tX685L1p2XrDsvuXWvdete69a91q17rXXXOOtXX1LrrnHWXeOsu8a5da+17hpn/epLal0vWddL1t0vuXWvdete69a91q17rdVvS/bbkv22ZL8t2W9LjtuS47bkuC15vWRdL1l3v+TWvdate61b91q37rXW72xfrd/Zvlq/s311617r1r3WrXutW/da63e2r9bvbF+t39+0qPU721fr93f7av3O9tX6ne2r9TvbV7futda6LfmrL6l1v8dZ93uctW9L/upLau3bkr/6klrXS9b9Hmfd73Fu3Wvdute6da91615r5R2Tv79NXut+j7Pu9zgr75j81b3Wyjsmf3+bvNb9Hmfd73HW/R7n1r3WrXutW/dat+61Vt2WrNuS93ucdb/H2b/6krp1r7V/Z/tq/+pLal8v2fd7nH2/x7l1r3XrXuvWvdate639O9tX+1dfUvtXQ1/7V19S+1dfUrfutfbvbF/tX31J7eslO262X31J3brXunWvdete69a91v6d7av9O9tX+3e2r27da92617p1r3XrXmvfNc6+a5x91zj7d7avnrrXE/5+4+zf2b7av7N9detea4/bkr/6ktp3v2Tf/ZJ91zi37rX2uC35qy+pffdL9t0v2XeNc+te69a91q17rVv3Wvt3tq9O3esT3jF5v8fZd41z615rrzsm17jhzXa/x9l3jXPrXv8N7yi585Jb91p735bctyXv9zj7fo+z7xrn1r3W3rcl923J6yX7fo+z7xrn1r3WrXutW/dat+61dt6WzNuSeVuybkveNc6te61dtyXrtuT1kl03213j3LrXunWvdete69a9Vv7O9lX+zvZV3jXOrXutW/dat+61bt1r5V3j5F3j5O/9JZV3jfPUvZ7w9xsnf2f7Kn9n++rWvVbe+pK8e6951zh5917zzktu3WvlrS/Ju/ead42Td42Td15y617r1r3WrXutW/da+TvbV/l7f0nlXePk/R4n77zk1r1W/s72Vf7eX1J51zh51zh55yW37rVu3Wvdute6da+V47bkrS/Ju8bJ+z1O3vqSW/daOW9L3vqSvF6Sd42Td41z617r1r3WrXutW/dauW5L3vqSvGucvPUleetLbt1r5boteetL8npJ3jVO3jXOrXutW/dat+61bt1r5V3j5F3j5O9sX92617p1r3XrXuvWvVb+zvZV/s72Vf7+pkXl72xfPXWv3/B3tq/yd7av8ne2r27da+WtL8lbX5K3viRvfUneecmte6269SV160vqrnHqrnHqzktu3Wvdute6da91616rfmf7qn7vHKj6ne2r+p3tq7rzklv3WvU721f1e+dA1V3j1F3j1J2X3LrXunWvdete69a9Vv3O9lXd+pL61dBX3fqSuvUlt+61qt+WvPUldb2k7hqn7hrn1r3WrXutW/dat+61qt+WvN/j1Lgteb/Hqfs9zq17rRq3Je/3OHW9pO4ap+4a59a91q17rVv3Wrfu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0873fTIxWQ9O1oOT+RX17UF9e1DfHtS3x0zG832fTPD+9pjst0/mV9S3xyzG832fTPD+9uD97cH724P69qC+PahvD+rbY93zzvG8v/2Jbzuve9451j3vHNS3x7rnneOpbz8xfsX724P3twf17UF9e1DfHtS3x2K//Xl/+xPfdl7sty/226lvj8V++1Pf/sTkZT3I+9uD+vagvj2obw/q22OxHlysBxfrQerbg/r2oL49qG+Pdc87x7rnnWPdv+cV6553jqe+/Ynv78F1zzvHuuedg/r2WIN2vu+TicV++2K/fTG/or491qSd7/tkYrEeXKwHF/Mr6tuD+vagvj2ob4+1GM/3fTKx2G9f7Lcv5lfUt8dajOf7PplYrAcX68HF/Ir69qC+PahvD+rbY23aedPOSTsn7Zy0c9LOSTsn7YxfLdaDi/Ug9e1BfXtQ3x7Ut8div30V7cx++2K/fbHfTn17LPbb962/io1fbdaDm/Ug9e1BfXtQ3x7Ut8dmPbhZD27Wg9S3B/XtQX17UN8e+553jn3PO8e+f88r9j3vHE99+4nveefY97xz7HveOahvj33rr2Lf+qvY7Ldv9ts386vN/Gp32vnWX8VmPbhZD27mV5v51WZ+tZlfbeZX+9ZfBe9vj81+O+9vD97fHry/Pfatvwre3x6b9SDvbw/e3x68vz14f3vw/vbg/e2xJ+1MPcOetDP1DLy/PXh/e+xFO1PPsPEr3t8evL89eH97bOoZeH97bPavNvvtm3oG6tuD+vagvj2obw/q24P69tj4Fe9vD97fHry/PXh/e/D+9uD97bFZD27Wg5v14L7nnWMnz2/y/BbP760XjX3PO8e+f88r9j3vHM/725/4/h7c97xz7HveOfb9e16R97xz5H2fTCT77cl+ezK/SuZXec87R973yUSyHkzWg8n8KplfJfOrZH6VzK94f3vw/vbg/e3B+9uD97cH728P3t8evL89qG8P3t8evL89eH978P724P3twfvbg/e3B+9vD97fHry/PXh/e/D+9uD97cH724P69uD97cH724P3twfvbw/e3x68vz14f3vw/vbg/e3B+9uD97cH728P3t8evL89qG8P3t8evL89eH978P724P3twfvbI1kPJuvBZD2Y97xz5D3vHHnPO8dT3/7E9/dg3vPO8dS3n/ied46nvv2J7+/BvOedI+95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Caa9MCWYEkwJpm0wJZj2wpRgSrAkWLbBkmDZC0uCJcGSYNkGS4JlL+iJTU9semLbtoGe2La9oCc2PbHpiW3bBnpiS3tBT2x6YtMTW9oGemJLe0FPbHpi0xNb2QZ6Yit7QU9semLTE1vZBnpiK3oh9MTQE0NPjE9XDMX005ZXtiIVtEHoidHohdATQ08MPTHaVEjQtp8mgZ4YemKEbaAnRtALoSeGnhh6YoRtoCdG2At6YuiJoSdGtw30xOj2gp4YemLoidFtAz0xhr2gJ4aeGHpiDNtAT4xhL+iJoSeGnhjTNtATY9oLjyeuIw7BPkKCaRvoiaEnxuOJ56P1xNATY9kGemLoifF44vNpEuiJ4Twx9MTQE+PxxPNpemLoieE8MfTE0BPj8cTn0yTQE8N5YuiJoSfG44nn0/TE0BPDeWLoiaEnRtkLemLoieE8MfTE0BOj7AU9MfTEcJ7Y9cSuJ/YPvdD1xK4ndueJXU/semL/pJ8mgZ7YnSd2PbHrib3RC11P7Hpid57Y9cSuJ/agF7qe2PXE7jyx64ldT+yx/DQJ9MTuPLHriV1P7N1e0BO7ntidJ3Y9seuJvdsLemLXE7vzxK4ndj2xD3tBT+x6Ynee2PXErif2aS/oiV1P7M4Tu/PE7jyxT3tBT+x6YtcTu/PErif2ZS/oiV1P7Hpid57Y9cS+7AU9seuJXU/szhO7nti3vaAndj2x64ndeWLXE3vaC3pi1xO7ntidJ3Y9sae9oCd2PbHrid15YtcTe9kLemLXE7ue2J0ndj2xl72gJw49ceiJw3ni0BPHh14YeuLQE4eeOJwnDj1xNHph6IlDTxx64nCeOPTE0ZafJoGeOPTE4Txx6Ikj6IWhJw49ceiJw3ni0BNHpJ8mgZ449MThPHHoiaPbC3ri0BOHnjicJw49cQx74fHEdcQhyCO6Yiim4kvwfZdOnHMsP5GKQhxPHAfneOIrvgTf9+/EmBJMCaYEjyc+4hCc+zme+AoJjie+oilC0WE7nviKeUD/xz//4f//v/z3//K//K//9T////7D/+v//lf+f/7P/+0//R//5b/9b4/8P/6v//298r/+9//yX//rf/n//s//+3//b//pP/+//8///p//5//63/7T37X/8Hn+8z/tvf/Zlf/xn//wb+b/af274bmi/ava9+Ksf/Yaf7L9yZX/7P35j/9+cnv//3/nlf/8O5V6/v/5+Wd93v/738n1P3Hk3//97+z4X9n//u94/++/yt5//qpZn///3wX+P/8usd9P+Csj/uevFPj9jL9a13/+ylr/PqX/GP4dYf/8terzKf9OA/759xfxj+PfUf/P38j9kfzb5n//fvx9yvj7lG/u+Zn//J3SuNn/3TL+q36+2WP881ck/Pf/zfv/rf3PX936/f/Wvx+09uf+f7n++Sub/I//43/8j//4P/4f","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use zkemail::{KEY_LIMBS_2048, dkim::RSAPubkey};\nuse dep::string_search::{StringBody, SubString128, SubString, SubString32, SubString64};\n\nglobal MAX_PARTIAL_EMAIL_BODY_LENGTH: u32 = 1216;\nglobal MAX_EMAIL_HEADER_LENGTH: u32 = 576;\nglobal MAX_EMAIL_ADDRESS_LENGTH: u32 = 60;\nglobal MAX_PURCHASE_NUMBER_LENGTH: u32 = 20;\ntype StringBody1280 = StringBody<1302, 42, 1280>;\ntype StringBody1408 = StringBody<1426, 46, 1408>;\n\nfn main(\n    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,\n    header_length: u32,\n    body: BoundedVec<u8, MAX_PARTIAL_EMAIL_BODY_LENGTH>,\n    pubkey: RSAPubkey<KEY_LIMBS_2048>,\n    signature: [Field; KEY_LIMBS_2048],\n    purchase_number: [u8; MAX_PURCHASE_NUMBER_LENGTH],\n    purchase_number_length: u32,\n    from_email_address: [u8; MAX_EMAIL_ADDRESS_LENGTH],\n    from_email_address_length: u32,\n    to_email_address: [u8; MAX_EMAIL_ADDRESS_LENGTH],\n    to_email_address_length: u32\n) {\n    verify_purchase(\n        header,\n        header_length,\n        body,\n        pubkey,\n        signature,\n        purchase_number,\n        purchase_number_length,\n        from_email_address,\n        from_email_address_length,\n        to_email_address,\n        to_email_address_length\n    )\n}\n\nfn verify_purchase(\n    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,\n    header_length: u32,\n    body: BoundedVec<u8, MAX_PARTIAL_EMAIL_BODY_LENGTH>,\n    pubkey: RSAPubkey<KEY_LIMBS_2048>,\n    signature: [Field; KEY_LIMBS_2048],\n    purchase_number: [u8; MAX_PURCHASE_NUMBER_LENGTH],\n    purchase_number_length: u32,\n    from_email_address: [u8; MAX_EMAIL_ADDRESS_LENGTH],\n    from_email_address_length: u32,\n    to_email_address: [u8; MAX_EMAIL_ADDRESS_LENGTH],\n    to_email_address_length: u32\n) {\n    // Check that the header's length is within bounds\n    assert(header.len() <= MAX_EMAIL_HEADER_LENGTH);\n\n    // Verify the dkim signature over the header\n    pubkey.verify_dkim_signature(header, signature);\n\n    // Construct haystack from header to search for substrings\n    let haystack: StringBody1280 = StringBody::new(body.storage, body.len);\n\n    assert_purchase_number_in_body(haystack, purchase_number, purchase_number_length);\n    assert_email_address_in_header(\n        header,\n        header_length,\n        from_email_address,\n        from_email_address_length\n    );\n    assert_email_address_in_header(\n        header,\n        header_length,\n        to_email_address,\n        to_email_address_length\n    );\n}\n\nfn assert_purchase_number_in_body(\n    haystack: StringBody1280,\n    purchase_number: [u8; MAX_PURCHASE_NUMBER_LENGTH],\n    purchase_number_length: u32\n) {\n    let purchase_number_substring: SubString128 = SubString::new(purchase_number, purchase_number_length);\n    let (match_found2, _): (bool, u32) = haystack.substring_match(purchase_number_substring);\n\n    assert(match_found2, \"header does not contain this purchase number\");\n}\n\nfn assert_email_address_in_header(\n    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,\n    header_length: u32,\n    email_address: [u8; MAX_EMAIL_ADDRESS_LENGTH],\n    email_address_length: u32\n) {\n    let email_addr: SubString64 = SubString::new(email_address, email_address_length);\n\n    let header_haystack: StringBody1408 = StringBody::new(header.storage, header_length);\n    let (email_found, _): (bool, u32) = header_haystack.substring_match(email_addr);\n\n    assert(email_found, \"header does not contain email address\");\n}\n","path":"/home/anon/zekshop/circuits/verify_purchase/src/main.nr"},"51":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"52":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"},"53":{"source":"use crate::{KEY_LIMBS_1024, KEY_LIMBS_2048, RSA_EXPONENT};\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse poseidon::poseidon;\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::{RBN1024, RBN2048}};\nuse sha256::sha256_var;\n\npub struct RSAPubkey<let KEY_LIMBS: u32> {\n    modulus: [Field; KEY_LIMBS],\n    redc: [Field; KEY_LIMBS],\n}\n\nimpl<let KEY_LIMBS: u32> RSAPubkey<KEY_LIMBS> {\n\n    pub fn new(modulus: [Field; KEY_LIMBS], redc: [Field; KEY_LIMBS]) -> Self {\n        let pubkey = Self { modulus, redc };\n        pubkey\n    }\n}\n\nimpl RSAPubkey<KEY_LIMBS_1024> {\n    pub fn verify_dkim_signature<let MAX_HEADER_LENGTH: u32>(\n        self,\n        header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n        signature: [Field; KEY_LIMBS_1024],\n    ) -> [u8; 32] {\n        // hash the header\n        let header_hash = sha256_var(header.storage(), header.len() as u64);\n\n        let params: BigNumParams<KEY_LIMBS_1024, 1024> = BigNumParams::new(\n            false,\n            convert_field_to_u128(self.modulus),\n            convert_field_to_u128(self.redc),\n        );\n\n        let signature: RBN1024 =\n            RuntimeBigNum::from_array(params, convert_field_to_u128(signature));\n        signature.validate_in_range();\n\n        // verify the DKIM signature over the header\n        assert(verify_sha256_pkcs1v15(header_hash, signature, RSA_EXPONENT));\n\n        header_hash\n    }\n\n    pub fn hash(self) -> Field {\n        // validate\n        self.validate_in_range();\n        let mut dkim_preimage = [0; 9];\n        // compose first 4 limbs of modulus and redc\n        for i in 0..4 {\n            let modulus_hi = self.modulus[i * 2] * 2.pow_32(120);\n            let redc_hi = self.redc[i * 2] * 2.pow_32(120);\n            dkim_preimage[i] = modulus_hi + self.modulus[i * 2 + 1];\n            dkim_preimage[i + 4] = redc_hi + self.redc[i * 2 + 1];\n        }\n        // compose last two elements of redc and modulus together\n        let modulus_hi = self.modulus[8] * 2.pow_32(120);\n        dkim_preimage[8] = modulus_hi + self.redc[8];\n        // hash the pubkey\n        poseidon::bn254::hash_9(dkim_preimage)\n    }\n\n    pub fn validate_in_range(self) {\n        for i in 0..(KEY_LIMBS_1024 - 1) {\n            self.modulus[i].assert_max_bit_size::<120>();\n            self.redc[i].assert_max_bit_size::<120>();\n        }\n        self.modulus[KEY_LIMBS_1024 - 1].assert_max_bit_size::<1024 - ((KEY_LIMBS_1024 - 1) * 120)>();\n        self.redc[KEY_LIMBS_1024 - 1].assert_max_bit_size::<120>();\n    }\n}\n\nimpl RSAPubkey<KEY_LIMBS_2048> {\n    pub fn verify_dkim_signature<let MAX_HEADER_LENGTH: u32>(\n        self,\n        header: BoundedVec<u8, MAX_HEADER_LENGTH>,\n        signature: [Field; KEY_LIMBS_2048],\n    ) -> [u8; 32] {\n        // hash the header\n        let header_hash = sha256_var(header.storage(), header.len() as u64);\n\n        let params: BigNumParams<KEY_LIMBS_2048, 2048> = BigNumParams::new(\n            false,\n            convert_field_to_u128(self.modulus),\n            convert_field_to_u128(self.redc),\n        );\n\n        let signature: RBN2048 =\n            RuntimeBigNum::from_array(params, convert_field_to_u128(signature));\n        signature.validate_in_range();\n\n        // verify the DKIM signature over the header\n        assert(verify_sha256_pkcs1v15(header_hash, signature, RSA_EXPONENT));\n\n        header_hash\n    }\n\n    pub fn hash(self) -> Field {\n        // validate range\n        self.validate_in_range();\n        let mut chunk1 = [0; 9];\n        let mut chunk2 = [0; 9];\n\n        // compose limbs\n        for i in 0..9 {\n            let modulus_hi = self.modulus[i * 2] * 2.pow_32(120);\n            let redc_hi = self.redc[i * 2] * 2.pow_32(120);\n            chunk1[i] = modulus_hi + self.modulus[i * 2 + 1];\n            chunk2[i] = redc_hi + self.redc[i * 2 + 1];\n        }\n\n        let hash_of_chunk1 = poseidon::bn254::hash_9(chunk1);\n        let hash_of_chunk2 = poseidon::bn254::hash_9(chunk2);\n\n        poseidon::bn254::hash_2([hash_of_chunk1, hash_of_chunk2])\n    }\n\n    pub fn validate_in_range(self) {\n        for i in 0..(KEY_LIMBS_2048 - 1) {\n            self.modulus[i].assert_max_bit_size::<120>();\n            self.redc[i].assert_max_bit_size::<120>();\n        }\n        self.modulus[KEY_LIMBS_2048 - 1].assert_max_bit_size::<2048 - ((KEY_LIMBS_2048 - 1) * 120)>();\n        self.redc[KEY_LIMBS_2048 - 1].assert_max_bit_size::<120>(); // we get 2053 sometimes?\n    }\n}\n\n// convert a Field array to a u128 array with generic number of limbs\nfn convert_field_to_u128<let KEY_LIMBS: u32>(signature: [Field; KEY_LIMBS]) -> [u128; KEY_LIMBS] {\n    let mut u128_signature: [u128; KEY_LIMBS] = [0; KEY_LIMBS];\n    for i in 0..KEY_LIMBS {\n        u128_signature[i] = signature[i] as u128;\n    }\n    u128_signature\n}\n","path":"/home/anon/nargo/github.com/zkemail/zkemail.nr/v.1.0.0-beta.5/lib/src/dkim.nr"},"104":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(field: Field) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<_, N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        // result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i]\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1]\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/constrained_ops.nr"},"105":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/expressions.nr"},"107":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [u128; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: u128 = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as u128;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: u128 = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as u128;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [u128; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = (val[i] as Field).to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = (val[N - 1] as Field).to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/serialization.nr"},"108":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120, TWO_POW_60};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb64;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 1;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> ([u128; N], [bool; N]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > params.modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + params.modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        borrow_flags[i] = borrow as bool;\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, params.modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = params.modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { params.modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry as bool;\n            borrow_flags[i] = borrow as bool;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N - 1);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[((N) - 1 - i)];\n        let v_low = v as u64 % TWO_POW_60 as u64;\n        let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n        if (v_high > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n            break;\n        }\n        if (v_low > 0) {\n            count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_helpers.nr"},"109":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> [u128; N] {\n    let f: [u128; N] = limbs;\n    __helper_sub(params.modulus, f)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, params.modulus) {\n        __helper_sub(result, params.modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    // ([0; N], [0; N])\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/fns/unconstrained_ops.nr"},"111":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/params.nr"},"112":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::Neg;\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes<let NBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        x: [u8; NBytes],\n    ) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    pub fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    pub unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    pub fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/runtime_bignum.nr"},"119":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir-bignum/v0.6.0/src/utils/split_bits.nr"},"137":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/anon/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"148":{"source":"use dep::bignum::RuntimeBigNum;\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\nmod tests {\n\n    use crate::types::RBN2048;\n    use super::verify_sha256_pkcs1v15;\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n}\n","path":"/home/anon/nargo/github.com/noir-lang/noir_rsa/v0.7.0/src/rsa.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__mul","__compute_quadratic_expression_with_borrow_flags","search","search","directive_integer_quotient","directive_invert","directive_to_radix"]}